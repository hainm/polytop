import re
import subprocess
import numpy as np

PUNCH_PATTERN = re.compile(r'\s+\d+\s+\d+\s+(\-\d|\d)\.\d+\s+(\-\d|\d)\.\d+\s+')

input_header = """ {CHR_TYP} project. RESP input generated by R.E.D. in Python
 @cntrl
  ioutopt=1, iqopt=1, nmol={n_confmodes}, ihfree=1, irstrnt=1, qwt= {qwt:5.4f} 
 &end 
  1.0
 {mol.title} 
{mol.chr_val:5}{mol.n_atoms:5d}          Column not used by RESP (Added by R.E.D. Python for information)"""

INPUT_EQUIV = "                    Inter-'molecular' charge equivalencing (i.e. for orientations, conformations or different molecules)"

def run_resp(input_no, name, extension=""):
    """ Run resp in the system """
    suffix = f'{name}{extension}'
    rinput = f'input{input_no}_{suffix}'
    routput = f'output{input_no}_{suffix}'
    punch = f'punch{input_no}_{suffix}'
    
    espot = f'espot_{suffix}'
    qwts = f'qwts_{suffix}'
    esout = f'esout_{suffix}'

    qqout = f'qout{input_no-1}_{suffix}'
    qtout = f'qout{input_no}_{suffix}'

    subprocess.run(['resp', '-0', '-i', rinput, '-o', routput, '-p', punch,
                    '-e', espot, '-q', qqout, '-t', qtout, '-w', qwts, '-s',
                    esout], stdout=subprocess.DEVNULL, 
                    stderr=subprocess.DEVNULL)


def charges_from_punch(filename):
    with open(filename, 'r') as f:
        content = [x.strip() for x in f.readlines()]
    
    charges = []
    for line in content:
        if re.match(PUNCH_PATTERN, line):
            subbed = re.sub(r'\s+', ':', line)
            try:
                ch = subbed.split(':')[4]
            except IndexError:
                raise ValueError('No charge found; job failed.'
                                 f' See {filename}')
            if 'nan' in ch or '*' in ch:
                raise ValueError('At least one charge equals zero!'
                                 f' See {filename}')
            charges.append(float(ch))
    return charges

def gen_punch(mol, charges, atom_name_indices, filename):
    lines = ["     Averaged ESP charges from punch1", "  Z     Equiv.    q(opt)	Rounding-Off"]

    for i, atom in enumerate(mol.atoms):
        indices = atom_name_indices.get(atom['name'], [i])
        equiv_charges = charges[indices]
        avg = np.mean(equiv_charges)
        z = atom['atomic_Z'] # Z
        j = indices[0]+1 # serial of first match
        lines.append(f"{z:<2d}     {j:<2d}     {avg:<8.7f}  {avg:<5.4f}")
    
    with open(filename, 'w') as f:
        f.write('\n'.join(lines))


def create_punch_files(mol, verify_intramolecular):
    indices = name_to_indices(mol)

    # punch1
    try:
        charges = charges_from_punch(f'punch1_{mol.name}')
        gen_punch(mol, charges, indices, f'punch2_{mol.name}')
    except FileNotFoundError:
        pass
    
    # punch1 sm
    try:
        charges = charges_from_punch(f'punch1_{mol.name}.sm')
        # for($j=0; $j<=$i; $j++){
        #     $y=$w=$imrv=0;
        #     for($y=0; $y<$imrcount[$NM]; $y++){
        #         for($w=0;$w<$intramr[4][$y][$NM];$w++){
        #             if($intratom[$w][$y][$NM]==$j){ $imrv=1; }
        #         }
        #     }
        #     if(($argimr==$equivimr[$j][$NM])&&($imrv !=1)){ $compt++; $total+=$qchargeimr[$j][$NM]; }
        # }

        if mol.intra_constraints:
            gen_punch(mol, charges, {}, f'punch2_{mol.name}.sm')
        else:
            gen_punch(mol, charges, indices, f'punch2_{mol.name}.sm')
    
    except FileNotFoundError:
        pass


def name_to_indices(mol):
    indices = {}
    for i, atom in enumerate(mol.atoms):
        if atom['name'] in indices:
            indices[atom['name']].append(i)
        else:
            indices[atom['name']] = [i]
    return indices

def read_gamess_dat(filename):
    with open(filename + '.dat', 'r') as f:
        content = [x.strip() for x in f.readlines()]
    
    atoms = []
    flag = False
    for line in content:
        if (('ELECTRIC POTENTIAL' in line 
            or 'TOTAL NUMBER OF GRID POINTS' in line):
            flag = True
        if flag:
            if 'START OF -MOLPLT- INPUT FILE' in line:
                flag = False
        if flag:
            point, *atom = map(float, line.split()[:5])
            atoms.append('{:16.7e}{:16.7e}{:16.7e}{:16.7e}'.format(atom))
        
    return point, atoms


def read_gamess_log(filename, mol):
    with open(filename + '.log', 'r') as f:
        content = [x.strip() for x in f.readlines()]
    
    flag = False
    atoms = []
    ctr = 0
    for line in content:
        if 'ATOM' in line and 'ATOMIC' in line and 'COORDINATES' in line:
            flag = True
        if flag and len(atoms) < len(mol.atoms):
            try:
                atom = map(float, line.split()[2:5])
                atoms.append('{}{:16.7e}{:16.7e}{:16.7e}'.format('', *atom))
            except:
                pass
    return atoms




def make_espot(mol):
    header = f'{mol.n_atoms:3d}{{pt:4d}}  {mol.chr_val:2d}          {mol.title}'
    all_lines = []

    for c in range(1, mol.n_confs+1):
        for m in range(1, mol.n_modes+1):
            prefix = f'JOB2-gam_{mol.name}-{c}-{w}'

            point, atoms = read_gamess_dat(prefix)
            atoms.extend(read_gamess_log(prefix))

            lines = [header.format(pt=point)] + atoms
            all_lines.extend(lines)
            filename = f'espot_{mol.name}-{c}-{m}'
            with open(filename, w) as f:
                f.write('\n'.join(lines))
    
    filename = f'espot_{mol.name}'
    with open(filename, 'w') as f:
        f.write('\n'.join(all_lines + ['', '']))
    
    if len(mol.n_modes) <= 1:
        if os.path('./espot1').isfile:
            os.remove('./espot1')

def input_gene(CHR_TYP, mol):
    # defaults
    testaff = True
    qwt = 0.005 # RESP/6-31G* (Connolly & chelpg) 2 stages
    if CHR_TYP in {'RESP-A1', 'RESP-C2'}:
        qwt = 0.01 # RESP/6-31G* (Connolly & chelpg) 1 stage
    elif CHR_TYP in {'ESP-A1', 'ESP-C1'}:
        qwt = 0.0000 # ESP/6-31G*  (Connolly & chelpg) 1 stage

    n_confmodes = mol.n_confs * mol.n_modes
    lines = [input_header.format(CHR_TYP=CHR_TYP, n_confmodes=n_confmodes,
                                 qwt=qwt, mol=mol)]
    atom_lines = []
    temps = []
    for i, atom in enumerate(mol.atoms, 1):
        line = f"  {atom['atomic_Z']:2d} {{temp}}                      {i:3d}"
        atom_lines.append(line)

        temp1 = 0
        temp2 = 0

        if atom.name[-1] != 'T':
            same = [x for x in mol.atoms if x.name_number == atom.name_number]
            if not any(x.name[-1] == T for x in same):
                for j, atom2 in enumerate(mol.atoms[:i-1], 1):
                    if atom2.name == atom.name:
                        temp = j
                        testaff = False
        temps.append(temp)
    

def testaff_confmodes(atom_line_templates, temps, n_confmodes):
    atom_lines = []
    for x, temp in zip(atom_line_templates, temps):
        atom_lines.append(x.format(temp=temp))

    if n_confmodes > 1:
        for each in range(n_confmodes-1):
            atom_lines.extend(['', f'1.0\n {mol.title}'] + atom_lines)
    
        if any(x == 0 for x in temps):
            atom_lines.append(INPUT_EQUIV)
            for i in range(1, len(temps)+1):
                if temps[i-1] == 0:
                    atom_lines.append(f'  {n_confmodes:3d}')
                    conf_line = ''
                    for j in range(1, n_confmodes):
                        conf_line += f'  {j:3d}  {i:3d}'
                        if not j % 4:
                            conf_line += '\n'
                    conf_line += f'  {j:3d}  {i:3d}'
                    atom_lines.append(conf_line)

    atom_lines.append('\n\n\n\n\n')
    return atom_lines




    
    


def CHR_Calcul(MEPCHR_Calc, Re_Fit, CHR_TYP, molecules):
    if MEPCHR_Calc and not Re_Fit:
        pass
        #makespot
        #inputgene
    elif Re_Fit:
        pass
        # check for espot files
    
    for i, mol in enumerate(molecules, 1):
        print(f"The {CHR_TYP} charges are being derived for molecule {i} ...")
        run_resp(1, mol.name)

        if CHR_TYP in {'RESP-A1', 'RESPC1'}:
            run_resp(2, mol.name)
            # run
        
        if verifimr == 2:
            run_resp(1, mol.name, '.sm')
            if CHR_TYP in {'RESP-A1', 'RESPC1'}:
                run_resp(2, mol.name, '.sm')
                # run
