import re
import subprocess
import numpy as np

PUNCH_PATTERN = re.compile(r'\s+\d+\s+\d+\s+(\-\d|\d)\.\d+\s+(\-\d|\d)\.\d+\s+')

input_header = """\
 {CHR_TYP} project. RESP input generated by R.E.D. in Python
 @cntrl
  ioutopt=1, iqopt=1, nmol={n_confmodes}, ihfree=1, irstrnt=1, qwt= {qwt:5.4f} 
 &end 
  1.0
 {mol.title} 
{mol.chr_val:5}{mol.n_atoms:5d}          Column not used by RESP (Added by R.E.D. Python for information)
"""

INPUT_INTER_REMARK = "                    Inter-'molecular' charge equivalencing (i.e. for orientations, conformations or different molecules)"
INPUT_INTRA_REMARK = "                    Intra and/or inter-molecular charge constraints for atom or group of atoms"

def run_resp(input_no, name, extension=""):
    """ Run resp in the system """
    suffix = f'{name}{extension}'
    rinput = f'input{input_no}_{suffix}'
    routput = f'output{input_no}_{suffix}'
    punch = f'punch{input_no}_{suffix}'
    
    espot = f'espot_{suffix}'
    qwts = f'qwts_{suffix}'
    esout = f'esout_{suffix}'

    qqout = f'qout{input_no-1}_{suffix}'
    qtout = f'qout{input_no}_{suffix}'

    subprocess.run(['resp', '-0', '-i', rinput, '-o', routput, '-p', punch,
                    '-e', espot, '-q', qqout, '-t', qtout, '-w', qwts, '-s',
                    esout], stdout=subprocess.DEVNULL, 
                    stderr=subprocess.DEVNULL)


def charges_from_punch(filename):
    with open(filename, 'r') as f:
        content = [x.strip() for x in f.readlines()]
    
    charges = []
    for line in content:
        if re.match(PUNCH_PATTERN, line):
            subbed = re.sub(r'\s+', ':', line)
            try:
                ch = subbed.split(':')[4]
            except IndexError:
                raise ValueError('No charge found; job failed.'
                                 f' See {filename}')
            if 'nan' in ch or '*' in ch:
                raise ValueError('At least one charge equals zero!'
                                 f' See {filename}')
            charges.append(float(ch))
    return charges

def gen_punch(mol, charges, atom_name_indices, filename):
    lines = ["     Averaged ESP charges from punch1", "  Z     Equiv.    q(opt)	Rounding-Off"]

    for i, atom in enumerate(mol.atoms):
        indices = atom_name_indices.get(atom['name'], [i])
        equiv_charges = charges[indices]
        avg = np.mean(equiv_charges)
        z = atom['atomic_Z'] # Z
        j = indices[0]+1 # serial of first match
        lines.append(f"{z:<2d}     {j:<2d}     {avg:<8.7f}  {avg:<5.4f}")
    
    with open(filename, 'w') as f:
        f.write('\n'.join(lines))


def create_punch_files(mol):
    indices = name_to_indices(mol)

    try:
        charges = charges_from_punch(f'punch1_{mol.name}')
        gen_punch(mol, charges, indices, f'punch2_{mol.name}')
    except FileNotFoundError:
        pass
    
    try:
        charges = charges_from_punch(f'punch1_{mol.name}.sm')
        if mol.intra_constraints:
            gen_punch(mol, charges, {}, f'punch2_{mol.name}.sm')
        else:
            gen_punch(mol, charges, indices, f'punch2_{mol.name}.sm')
    except FileNotFoundError:
        pass


def name_to_indices(mol):
    indices = {}
    for i, atom in enumerate(mol.atoms):
        if atom['name'] in indices:
            indices[atom['name']].append(i)
        else:
            indices[atom['name']] = [i]
    return indices

def read_gamess_dat(filename):
    with open(filename + '.dat', 'r') as f:
        content = [x.strip() for x in f.readlines()]
    
    atoms = []
    flag = False
    for line in content:
        if ('ELECTRIC POTENTIAL' in line
            or 'TOTAL NUMBER OF GRID POINTS' in line):
            flag = True
        if flag:
            if 'START OF -MOLPLT- INPUT FILE' in line:
                flag = False
        if flag:
            point, *atom = map(float, line.split()[:5])
            atoms.append('{:16.7e}{:16.7e}{:16.7e}{:16.7e}'.format(*atom))
    
    return point, atoms


def read_gamess_log(filename, mol):
    with open(filename + '.log', 'r') as f:
        content = [x.strip() for x in f.readlines()]
    
    flag = False
    atoms = []
    for line in content:
        if 'ATOM' in line and 'ATOMIC' in line and 'COORDINATES' in line:
            flag = True
        if flag and len(atoms) < len(mol.atoms):
            try:
                atom = map(float, line.split()[2:5])
                atoms.append('{}{:16.7e}{:16.7e}{:16.7e}'.format('', *atom))
            except:
                pass
    return atoms




def make_espot(mol):
    header = f'{mol.n_atoms:3d}{{pt:4d}}  {mol.chr_val:2d}          {mol.title}'
    all_lines = []

    for c in range(1, mol.n_confs+1):
        for m in range(1, mol.n_modes+1):
            prefix = f'JOB2-gam_{mol.name}-{c}-{w}'

            point, atoms = read_gamess_dat(prefix)
            atoms.extend(read_gamess_log(prefix))

            lines = [header.format(pt=point)] + atoms
            all_lines.extend(lines)
            filename = f'espot_{mol.name}-{c}-{m}'
            with open(filename, w) as f:
                f.write('\n'.join(lines))
    
    filename = f'espot_{mol.name}'
    with open(filename, 'w') as f:
        f.write('\n'.join(all_lines + ['', '']))
    
    if len(mol.n_modes) <= 1:
        if os.path('./espot1').isfile:
            os.remove('./espot1')

def input_gene(CHR_TYP, mol):
    n_confmodes = mol.n_confs * mol.n_modes
    # defaults
    testaff = True
    qwt = 0.0000
    if CHR_TYP in {'RESP-A1', 'RESP-C1'}:
        qwt = 0.005 # RESP/6-31G* (Connolly & chelpg) 2 stages
    elif CHR_TYP in {'RESP-A2', 'RESP-C2'}:
        qwt = 0.01 # RESP/6-31G* (Connolly & chelpg) 1 stage

    
    lines = [input_header.format(CHR_TYP=CHR_TYP, n_confmodes=n_confmodes,
                                 qwt=qwt, mol=mol)]
    atom_lines = ['', f'1.0\n {mol.title}']
    temps = []

    if CHR_TYP in {'RESP-A1', 'RESP-C1'}:
        get_atom_temps = resp_1_temps
    elif CHR_TYP in {'ESP-A1', 'ESP-C1', 'RESP-A2', 'RESP-C2'}:
        get_atom_temps = resp_2_temps
    else:
        get_atom_temps = esp_temps

    for i, atom in enumerate(mol.atoms, 1):
        line = f"  {atom['atomic_Z']:2d} {{temp}}                      {i:3d}"
        atom_lines.append(line)
        temps.append(get_atom_temps(i, atom, mol))
    
    temp1, temp2, temp3, temp4 = zip(*temps)

    atoms1, inter_confs1 = input_inter(atom_lines, temp1, n_confmodes)
    atoms2, inter_confs2 = input_inter(atom_lines, temp2, n_confmodes)
    atoms3, inter_confs3 = input_inter(atom_lines, temp3, n_confmodes)
    atoms4, inter_confs4 = input_inter(atom_lines, temp4, n_confmodes)

    intra_confs = input_intra(mol)

    if n_confmodes > 1:
        intra_confs.insert(0, INPUT_INTRA_REMARK)
    
    with open(f'input1_{mol.name}', 'w') as f:
        f.write('\n'.join(lines + atoms1 + inter_confs1))
    
    with open(f'input2_{mol.name}', 'w') as f:
        f.write('\n'.join(lines + atoms2 + inter_confs2))
    
    with open(f'input1_{mol.name}.sm', 'w') as f:
        f.write('\n'.join(lines + atoms3 + intra_confs + inter_confs3))

    with open(f'input2_{mol.name}.sm', 'w') as f:
        f.write('\n'.join(lines + atoms4 + inter_confs4))
    
    
        

def input_intra(mol):
    lines = []
    conf_line = ''
    for constr in mol.intra_constraints:
        n_atoms = len(constr.atoms)
        lines.append('')
        lines.append(f'  {n_atoms} {constr.value: 3.2f}') # TODO: is this what %3f means??

        for i, atom in enumerate(constr.atoms):
            conf_line += f'    1  {atom:3d}'
            if i and not i % 8 and not i == n_atoms:
                conf_line += '\n'
    lines.append(conf_line)
    return lines


def input_inter(atom_line_templates, temps, n_confmodes):
    templates = []
    atom_lines = []
    conf_lines = []
    for x, temp in zip(atom_line_templates, temps):
        templates.append(x.format(temp=temp))

    for each in range(n_confmodes):
        atom_lines.extend(templates)

    if any(x == 0 for x in temps):
        conf_lines.append(INPUT_INTER_REMARK)
        for i in range(1, len(temps)+1):
            if temps[i-1] == 0:
                conf_lines.append(f'  {n_confmodes:3d}')
                conf_line = ''
                for j in range(1, n_confmodes):
                    conf_line += f'  {j:3d}  {i:3d}'
                    if j and not j % 8:
                        conf_line += '\n'
                conf_line += f'  {j:3d}  {i:3d}'
                conf_lines.append(conf_line)

    conf_lines.append('\n\n\n\n\n')
    return atom_lines[2:], conf_lines # extra 1.0\n mol.title in atom_lines

def resp_1_temps(i, atom, mol):
    temp1 = temp2 = temp3 = temp4 = 0

    flag = False
    for constr in mol.intra_constraints:
        if i in constr.atoms:
            temp4 = -1
    else:
        flag = True

    if atom.name[-1] != 'T':
        for j, atom2 in enumerate(mol.atoms[:i-1], 1):
            if atom2.name == atom.name:
                temp1 = j
                temp2 = j
                temp3 = j
                temp4 = j
                break
        
        for atom2 in mol.atoms:
            if atom2.name_number == atom.name_number:
                if atom2.name[-1] == 'T':
                    break
        else:
            temp2 = -1
            temp4 = -1
    
    else:
        for j, atom2 in enumerate(mol.atoms[:i-1], 1):
            if atom2.name == atom.name:
                temp2 = j
                temp4 = j
                break
    
    if not flag:
        temp4 = -1

    return temp1, temp2, temp3, temp4

def resp_2_temps(i, atom, mol):
    temp1 = temp2 = temp3 = temp4 = 0
    
    flag = False
    for constr in mol.intra_constraints:
        if i in constr.atoms:
            temp4 = -1
    else:
        flag = True

    for j, atom2 in enumerate(mol.atoms[:i-1], 1):
        if atom2.name == atom.name:
            temp1 = j
            temp2 = j
            temp3 = j
            temp4 = j
            break
        
    for atom2 in mol.atoms:
        if atom2.name_number == atom.name_number:
            if atom2.name[-1] == 'T':
                break
    else:
        temp2 = -1
        temp4 = -1

    if not flag:
        temp4 = -1

    return temp1, temp2, temp3, temp4

def esp_temps(i, atom, mol):
    temp1 = temp2 = temp3 = temp4 = 0
    
    flag = False
    for constr in mol.intra_constraints:
        if i in constr.atoms:
            temp4 = -1
    else:
        flag = True

    for j, atom2 in enumerate(mol.atoms[:i-1], 1):
        if atom2.name == atom.name:
            temp2 = j
            temp3 = j
            temp4 = j
            break
        
    for atom2 in mol.atoms:
        if atom2.name_number == atom.name_number:
            if atom2.name[-1] == 'T':
                break
    else:
        temp2 = -1
        temp4 = -1

    if not flag:
        temp4 = -1
        temp3 = 0

    return temp1, temp2, temp3, temp4
    


def CHR_Calcul(MEPCHR_Calc, Re_Fit, CHR_TYP, molecules):
    if MEPCHR_Calc and not Re_Fit:
        for mol in molecules:
            make_espot(mol)
            input_gene(CHR_TYP, mol)

    elif Re_Fit:
        pass
        # check for espot files
    
    for i, mol in enumerate(molecules, 1):
        print(f"The {CHR_TYP} charges are being derived for molecule {i} ...")
        run_resp(1, mol.name)
        run_resp(1, mol.name, '.sm')

        if CHR_TYP in {'RESP-A1', 'RESP-C1'}:
            run_resp(2, mol.name)
            run_resp(2, mol.name, '.sm')
    

        if CHR_TYP in {'ESP-A2', 'ESP-C2'}:
            create_punch_files(mol)
        
        # create mol files?